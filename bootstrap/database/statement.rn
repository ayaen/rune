//  Copyright 2021 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use root
use filepath
use location
use block
use expr
use rel
use value

import cbackend as c

enum StateType {
  Assert
  If
  ElseIf
  Else
  Switch
  Case
  Default
  Do
  While
  For
  Assign
  Call
  Panic
  Print  // print "Hello, World!\n"
  Println  // println "Hello, World!"
  Try
  Except
  Raise
  Return
  Transform
  Relation
  Appendcode
  Prependcode
  Use
  Import
  ImportLib
  ImportRpc
  Foreach
  Yield
  Ref  // These two are used by transformers to manage reference counts.
  Unref
}

// Get the statement type keyword.
export func statementTypeGetKeyword(type: StateType) {
  switch type {
    StateType.Assert => return "assert"
    StateType.If => return "if"
    StateType.ElseIf => return "else if"
    StateType.Else => return "else"
    StateType.Do => return "do"
    StateType.While => return "while"
    StateType.For => return "for"
    StateType.Foreach => return "foreach"
    StateType.Assign => return "assignment"
    StateType.Call => return "call"
    StateType.Panic => return "panic"
    StateType.Print => return "print"
    StateType.Println => return "println"
    StateType.Try => return "try"
    StateType.Except => return "except"
    StateType.Raise => return "raise"
    StateType.Return => return "return"
    StateType.Switch => return "switch"
    StateType.Case => return "case"
    StateType.Default => return "default"
    StateType.Relation => return "relation"
    StateType.Transform => return "transform"
    StateType.Appendcode => return "appendcode"
    StateType.Prependcode => return "prependcode"
    StateType.Use => return "use"
    StateType.Import => return "import"
    StateType.ImportLib => return "importlib"
    StateType.ImportRpc => return "importrpc"
    StateType.Yield => return "yield"
    StateType.Ref => return "ref"
    StateType.Unref => return "unref"
  }
}

// Represents all statements in Rune.
class Statement(self, block: Block, type: StateType, location: Location) {
  self.type = type
  self.location = location
  self.instantiated = false
  self.executed = false  // Only for relation statements, so we don't execute them twice.
  self.generated = false // This statement was generated by a transformer or iterator.
  self.isFirstAssignment = false  // True if this is the first assignment to a variable, at top level.
  block.appendStatement(self)

  // Dump a statement to |text| without its sub-block.
  func dumpNoSubBlock(self:Statement, var text: string) {
    getRoot().indent(text)
    needSpace = false
    if self.type != StateType.Assign && self.type != StateType.Call {
      text.concat(statementTypeGetKeyword(self.type))
      needSpace = true
    }
    expr = self.expr
    if !isnull(expr) {
      if needSpace {
        text.append(' ')
      }
      expr.dumpToString(text)
    }
  }

  // Dump the statement to the end of |text| for debugging purposes.
  func dumpToString(self, var text: string) {
    self.dumpNoSubBlock(text)
    block = self.subBlock
    if !isnull(block) {
      text += " {\n"
      getRoot().incrementIndent()
      block.dumpToString(text)
      getRoot().decrementIndent()
      getRoot().indent(text)
      text += "}\n"
    } else {
      text += "\n"
    }
  }

  // Dump the statement to stdout for debugging purposes.
  func dump(self) {
    text = ""
    self.dumpToString(text)
    println text
  }

  // Copy a statement's expression and sub-block to the new statement.
  func copyExprAndSubBlock(self, newStatement: Statement) {
    expr = self.expr
    if !isnull(expr) {
      newExpr = expr.copy()
      newStatement.insertExpr(newExpr)
    }
    subBlock = self.subBlock
    if !isnull(subBlock) {
      newSubBlock = subBlock.copy()
      newStatement.insertSubBlock(newSubBlock)
    }
  }

  // Append a deep copy of the statement to destBlock.
  func appendCopy(self, destBlock: Block) -> Statement {
    newStatement = Statement(destBlock, self.type, self.location)
    self.copyExprAndSubBlock(newStatement)
    newStatement.instantiated = self.instantiated
    newStatement.executed = self.executed
    newStatement.generated = self.generated
    return newStatement
  }

  // Prepend a deep copy of the statement to destBlock.
  func prependCopy(self, destBlock: Block) -> Statement {
    newStatement = self.appendCopy(destBlock)
    // Move the statement to the start of the block.
    destBlock.removeStatement(newStatement)
    destBlock.insertStatement(newStatement)
    return newStatement
  }

  // Append a deep copy of the statement to destStatement's block, right after
  // |destStatement|.
  func appendCopyAfterStatement(self, destStatement: Statement) -> Statement {
    destBlock = destStatement.block!
    newStatement = self.appendCopy(destBlock)
    destBlock.removeStatement(newStatement)
    destBlock.insertAfterStatement(destStatement, newStatement)
    return newStatement
  }

  // C Generator .................................................

  func genC(self, builder: c.CBuilder) {
    switch self.type {
      StateType.Assign => self.genCAssign(builder)
      StateType.Println => self.genCPrintln(builder)
      default => raise Status.Unimplemented, "Statement type not yet supported by C backend builder ", self.type
    }
  }

  func genCAssign(self, builder: c.CBuilder) {
    assert isnull(self.subBlock)
    assert !isnull(self.expr)
    cexpr = self.expr.genC(builder)
    builder.addStatement(c.CStatement(cexpr))
  }

  func genCPrintln(self, builder: c.CBuilder) {
    assert isnull(self.subBlock)
    assert !isnull(self.expr)

    // This expr will be a list of parameters.
    args = self.expr.genC(builder)
    assert args.type == c.CExpr.Type.List

    // Add a trailing newline to 1st element of the list
    firstElement = args.cExprList.index(0)
    // TODO: handle case where first element is not a format string.
    // e.g., println 1
    assert firstElement.type == c.CExpr.Type.Literal
    assert firstElement.cLiteral.type == c.CLiteral.Type.String
    firstElement.cLiteral.stringValue += "\\n"
    builder.addStatement(builder.cPrintlnStatement(self.location, args))
  }
}

relation DoublyLinked Block Statement cascade
relation DoublyLinked Relation:"Generated" Statement:"Generated" cascade
relation OneToOne Root:"LastInitializer" Statement:"LastInitializer"

unittest basicStatementTest {
  filepath = Filepath.new("test_filepath", null(Filepath), false)
  location = Location(filepath, 0u32, 0u32, 0u32)
  block = Block(location);
  statement =  Statement(block, StateType.Print, location)
  expr = Expr.newConstant(Value("Hello, World!\n"), location)
  statement.insertExpr(expr)
  statement.dump()
}
