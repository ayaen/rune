//  Copyright 2023 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License")
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This will likely become the Rune lexer.  For now, it is only lexing syntax files.

import io
use sym

import database as db
use char
use keytab
use token

class Lexer(self, filepath: db.Filepath, keytab: Keytab, readFile: bool = true) {
  if filepath.text.length() == 0 {
    if readFile {
      filepath.readFile()
    }
  }
  self.pos = 0u32
  self.len = <u32>filepath.text.length()
  self.line = 1u32
  self.startPos = 0u32
  self.keytab = keytab
  filepath.insertLexer(self)

  func parseToken(self) -> Token {
    if self.eof() {
      return self.eofToken()
    }
    // No further checks for eof are needed because the file always ends in a newline.
    self.skipSpace()
    self.startPos = self.pos
    char = self.readChar()
    self.checkCharValid(char)
    c = self.filepath!.text[char.pos]
    if c == '"' {
      return self.parseString()
    } else if c == '\'' {
      return self.parseAsciiChar()
    } else if isDigit(c) {
      return self.parseNumber()
    } else if c == '\' {
      return self.parseEscapedIdent()
    } else if isalpha(c) || char.len > 1 {
      self.readIdentOrKeyword(char)
    }
    return self.parseNonAlphaKeyword(char)

    func isalpha(c) -> bool {
      return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z'
    }
  }

  // Skip space and comments in the input.  Do not skip newlines.
  func skipSpace(self) {
    do {
      c = self.filepath!.text[self.pos]
    } while c == ' ' || c == '\r' || c == '\t' {
      self.pos += 1
    }
  }

  func eof(self) {
    return self.pos >= self.len
  }

  // A non-ASCII UTF-8 character will match ([\xc0-\xff][\x80-\xbf]*).
  func readChar(self) -> Char {
    char = getChar(self.filepath!.text, self.pos)
    self.pos += <u32>char.len
    return char
  }

  func eofToken(self) {
    assert self.eof()
    return Token(TokenType.Eof, db.Location(self.filepath!, self.len, 0u32, self.line))
  }

  func error(self, msg: string) {
    self.location().error(msg)
    raise Status.InvalidArgument
  }

  func parseString(self) -> Token {
    s = ""
    do {
      if self.eof() {
        self.error("End of file while reading string")
      }
      char = self.readChar()
      c = self.filepath!.text[char.pos]
    } while c != '"' {
      if c == '\\' {
        s.append(self.readEscapedChar(false))
      } else {
        for i in range(char.pos, char.pos + <u32>char.len) {
          s.append(self.filepath!.text[i])
        }
      }
    }
    return Token.newValueToken(s, self.location())
  }

  // Read an escaped character.  If in single quotes, escape single quotes,
  // otherwise escape double quotes.
  func readEscapedChar(self, singleQuotes: bool) -> u8 {
    char = self.readChar()
    c = self.filepath!.text[char.pos]
    if c == 'a' {
      return '\a'
    } else if c == 'b' {
      return '\b'
    } else if c == 'e' {
      return '\e'
    } else if c == 'f' {
      return '\f'
    } else if c == 'n' {
      return '\n'
    } else if c == 'r' {
      return '\r'
    } else if c == 't' {
      return '\t'
    } else if c == 'v' {
      return '\v'
    } else if c == '\\' {
      return '\\'
    } else if c == '"' && !singleQuotes{
      return '"'
    } else if c == '\'' && singleQuotes {
      return '\''
    } else if c == '0' {
      return '\0'
    } else if c == 'x' {
      char = self.readChar()
      hi = self.filepath!.text[char.pos]
      char = self.readChar()
      lo = self.filepath!.text[char.pos]
      if !isHexDigit(hi) || !isHexDigit(lo) {
        self.error("Non-hex digit in hexadecimal escape sequence")
      }
      return hexToChar(hi, lo)
    }
    self.startPos = char.pos
    self.error("Invalid escape sequence")
    return '\0'  // Dummy return.
  }

  func checkCharValid(self, char: Char) {
    if !char.valid {
      self.error("Invalid character")
    }
  }

  // Returns a single quoted char as a u8 integer token.
  func parseAsciiChar(self) -> Token {
    char = self.readChar()
    self.checkCharValid(char)
    if char.len != 1 {
      self.error("Only single-byte characters can be used in single quotes")
    }
    c = self.filepath!.text[char.pos]
    if c == '\\' {
      c = self.readEscapedChar(true)
    }
    self.expectChar('\'')
    return Token.newValueToken(c, db.Location(self.filepath!, char.pos, 1u32, self.line))
  }

  func expectChar(self, expectedChar: u8) {
    char = self.readChar()
    c = self.filepath!.text[char.pos]
    if c != expectedChar {
      self.error("Expected %s, got %s" % (chr(expectedChar), chr(c)))
    }
  }

  func parseNumber(self) -> Token {
    self.pos -= 1  // Rewind to start.
    intVal = self.parseRawInteger()
    filepath = self.filepath!
    c = filepath.text[self.pos]
    if c == '.' || c == 'f' || c == 'e' {
      return self.parseFloat(intVal)
    }
    if c == 'x' && self.pos == self.startPos + 1 && filepath.text[self.startPos] == '0' {
      self.pos += 1
      intVal = self.parseHexInteger()
    }
    return self.parseIntegerSuffix(intVal)
  }

  func parseIntegerSuffix(self, intVal: db.Bigint) -> Token {
    filepath = self.filepath!
    width = db.Bigint(64u32)
    c = filepath.text[self.pos]
    if c == 'i' || c == 'u' {
      self.pos += 1
      width = self.parseWidthSpec()
    }
    intWidth = <u32>width
    if intVal.width > intWidth {
      newIntVal = intVal.resize(intWidth, true)
      if newIntVal.resize(newIntVal.width) != intVal {
        self.error("Constant does not fit in integer width")
      }
    } else if intVal.width < intWidth {
      newIntVal = intVal.resize(intWidth)
    } else {
      newIntVal = intVal
    }
    if (c == 'i') {
      newIntVal = newIntVal.cast(newIntVal.width, true, intVal.isSecret)
    }
    return Token.newValueToken(newIntVal, self.location())
  }

  func parseWidthSpec(self) {
    filepath = self.filepath!
    c = filepath.text[self.pos]
    if c < '1' || c > '9' {
      self.error("Invalid integer width spec")
    }
    newWidth = self.parseRawInteger()
    if newWidth > <newWidth>0xffff {
      self.error("Integer widths must be < 2^16")
    }
    return newWidth.resize(32u32)
  }

  // Parse a raw integer.  If the first character is not a digit,
  // returns Bigint(0).  The width is set to the minimum width needed to
  // fit the unsigned integer.
  func parseRawInteger(self) {
    filepath = self.filepath!
    width = 8u32
    intVal = db.Bigint(0, width)
    do {
      c = filepath.text[self.pos]
    } while isDigit(c) || c == '_' {
      self.pos += 1
      if c != '_' {
        if (intVal << 5u32) >> 5u32 != intVal {
          width += 8
          intVal = intVal.cast(width, intVal.isSigned, intVal.isSecret, false)
        }
        intVal = (intVal * <intVal>10) + <intVal>(c - '0')
      }
    }
    return intVal.shrinkToFit()
  }

  // Count the number of 0-9 digits in the input stream.
  func countDigits(self) -> u32 {
    filepath = self.filepath!
    numDigits = 0u32
    while isDigit(filepath.text[self.pos + numDigits]) {
      numDigits += 1
    }
    return numDigits
  }

  func parseFloat(self, intVal) -> Token {
    fracVal = db.Bigint(0)
    width = 64u32
    exp = 0i32
    fracDigits = 0u32
    filepath = self.filepath!
    c = filepath.text[self.pos]
    if c == '.' {
      self.pos += 1
      fracDigits = self.countDigits()
      fracVal = self.parseRawInteger()
      c = filepath.text[self.pos]
    }
    if c == 'e' {
      negateExp = false
      if filepath.text[self.pos + 1] == '-' {
        self.pos += 1
        negateExp = true
      }
      if !isDigit(filepath.text[self.pos]) {
        self.error("Missing exponent after 'e' in floating point number")
      }
      exp = <i32><u32>self.parseRawInteger()
      if negateExp {
        exp = -exp
      }
    }
    if c == 'f' {
      self.pos += 1
      width = <u32>self.parseRawInteger()
      if width != 32u32  && width != 64u32 {
        self.error("Only 32 and 64 bit floating point numbers are currently supported.")
      }
    }
    return self.buildFloatToken(intVal, fracVal, fracDigits, exp, width)
  }

  func buildFloatToken(self, intVal: db.Bigint, fracVal: db.Bigint, fracDigits: u32,
      exp: i32, width: u32) {
    val = <f64><u64>intVal + (<f64><u64>fracVal + 0.5f64) / pow(10.0f64, fracDigits)
    val = val * pow(10.0f64, exp)
    return Token.newValueToken(val, self.location())

    // The Rune C compiler needs o be enhanced to support floating point exponentiation.
    func pow(base, exp) {
      result = <base>1
      invert = exp < 0
      for i in range(invert? -exp : exp) {
        result *= base
      }
      if invert {
        return 1.0f64 / result
      }
      return result
    }
  }

  // Return the location from self.startPos to self.pos.
  func location(self) {
    return db.Location(self.filepath!, self.startPos, self.pos - self.startPos, self.line)
  }

  // Parse the hex chars, but don't parse the width spec.
  func parseHexInteger(self) -> db.Bigint {
    filepath = self.filepath!
    intVal = db.Bigint(0u1)
    width = 0
    do {
      c = filepath.text[self.pos]
    } while isHexDigit(c) || c == '_' {
      if c != '_' {
        newIntVal = intVal.resize(intVal.width + 4) << 4u32
        intVal = newIntVal | db.Bigint(hexDigit(c), newIntVal.width)
      }
      self.pos += 1
    }
    return intVal.shrinkToFit()
  }

  func parseEscapedIdent(self) -> Token {
    return self.eofToken()  // TODO: Write me.
  }

  func readIdentOrKeyword(self, char: Char) -> Token {
    return self.eofToken()  // TODO: Write me.
  }

  // Read up to 3 characters to see if it matches a keyword.
  // Try longest to shortest.
  func parseNonAlphaKeyword(self, char: Char) -> Token {
    for i in [3, 2, 1] {
      keyword = self.tryNonAlphaKeyword(i)
      if !isnull(keyword) {
        return Token.newValueToken(keyword!, self.location())
      }
      self.pos = self.startPos
    }
    self.error("Parser error: keyword not found")
    return self.eofToken()  // Dummy return.

  }

  // See if a `len` character keyword exists in the keyword table.
  func tryNonAlphaKeyword(self, len: u64) -> Token {
    for i in range(len) {
      char = self.readChar()
    }
    text = self.filepath!.text[self.startPos : self.pos]
// temp
println "looking up ", text
    keytab = self.keytab!
    return keytab.lookup(text)
  }
}

relation OneToOne db.Filepath Lexer cascade

unittest emptyTest {
  filepath = db.Filepath("testdata/empty", null(db.Filepath), false)
  keytab = Keytab()
  lexer = Lexer(filepath, keytab, false)
  assert lexer.len == 0
  assert lexer.eof()
  token = lexer.parseToken()
  assert token.type == TokenType.Eof
  lexer.destroy()
  println "Passed empty test"
}

unittest {
  func newLexer(text: string) {
    filepath = db.Filepath("testdata/empty", null(db.Filepath), false)
    filepath.text = text + "\n"
    keytab = Keytab()
    Keyword(keytab, "\n")
    return Lexer(filepath, keytab, false)
  }
}

unittest parseEscapedCharsTest {
  lexer = newLexer("\"\\a\\b\\e\\f\\n\\r\\t\\v\\\\\\\"\\0\\xde\\xad\"")
  token = lexer.parseToken()
  assert token.type == TokenType.String
  value = token.value!
  assert value.type == db.Datatype.String
  s = value.stringVal
  assert s[0] == '\x07'  // Bell.
  assert s[1] == '\x08'  // Backspace.
  assert s[2] == '\x1b'  // Escape.
  assert s[3] == '\x0c'  // Formfeed.
  assert s[4] == '\x0a'  // Newline.
  assert s[5] == '\x0d'  // Return.
  assert s[6] == '\x09'  // Tab.
  assert s[7] == '\x0b'  // Vertical tab.
  assert s[8] == '\\'
  assert s[9] == '"'
  assert s[10] == '\0'
  assert s[11] == '\xde'
  assert s[12] == '\xad'
  println "Passed escaped chars test"
}

unittest badInputTest {
  // Overlong encoding of '\0'
  lexer = newLexer("\xc0\x80")
  try {
    lexer.parseToken()
    panic "Failed invalid character test"
  } except e {
    default => println "Caught invalid character"
  }
  lexer.destroy()
  lexer = newLexer("\"\\x0g\"")
  try {
    lexer.parseToken()
    panic "Failed invalid hex escape test"
  } except e {
    default => println "Caught invalid hex escape"
  }
  lexer.destroy()
  lexer = newLexer("\"\\z\"")
  try {
    lexer.parseToken()
    panic "Failed invalid escape sequence"
  } except e {
    default => println "Caught invalid escape sequence"
  }
  lexer.destroy()
  lexer = newLexer("\"no end quote")
  try {
    lexer.parseToken()
    panic "Failed to catch unexpeced end of file"
  } except e {
    default => println "Caught unexpected end of file"
  }
  println "Passed bad input test"
}

unittest parseEscapedSingleQuotedCharsTest {
  lexer = newLexer("'\\a' '\\b' '\\e' '\\f' '\\n' '\\r' '\\t' '\\v' '\\\\' '\\'' '\\0' '\\xde' '\\xad'")
  expRes = ['\x07' /* Bell */, '\x08' /* Backspace */, '\x1b' /* Escape */, '\x0c' /* Formfeed */,
      '\x0a' /* Newline */, '\x0d' /* Return */, '\x09' /* Tab */, '\x0b' /* Vertical tab */,
      '\\', '\'', '\0', '\xde', '\xad']
  for i in range(expRes.length()) {
    token = lexer.parseToken()
    assert token.type == TokenType.Integer && token.value!.intVal! == db.Bigint(expRes[i])
  }
  println "Passed escaped chars test"
}

unittest parseIntegerTest {
  lexer = newLexer("0 1u2 3i3 57896044618658097711785492504343953926634992332820282019728792003956564819949u256")
  expRes = ["0u64", "1u2", "3i3", "57896044618658097711785492504343953926634992332820282019728792003956564819949u256"]
  i = 0
  do {
    token = lexer.parseToken()
  } while !token.isKeyword("\n") {
    println "token value = ", token.value!.intVal!.toString()
    println "expected    = ", expRes[i]
    assert token.type == TokenType.Integer && token.value!.intVal!.toString() == expRes[i]
    i += 1
  }
  println "Passed parse integer test"
}

unittest parseHexTest {
  lexer = newLexer("0x0 0xau4 0x3i3 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffedu256")
  expRes = ["0u64", "au4", "3i3", "7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffedu256"]
  for i in  range(expRes.length()) {
    token = lexer.parseToken()
    intValStr = token.value!.intVal!.toStringInBase(16u32)
    println "token value = ", intValStr
    println "expected    = ", expRes[i]
    assert token.type == TokenType.Integer && intValStr == expRes[i]
  }
  println "Passed parse integer test"
}
