//  Copyright 2021 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License")
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use sym

use root
use line
use filepath
use value
use expr
use ident
use statement
use block
use variable

enum FuncType {
  Plain  // Includes methods.
  Operator  // Overloaded operator.
  Constructor
  Destructor
  Package  // Initializes all modules in the package.
  Module  // Initializes the module.
  Iterator
  Final
  Struct
  Enum
  Transformer
  Unittest
}

// Function linking type.
enum Linkage {
  Module  // Default, like Python, files in the same directory can access.
  Package  // Allow files in other directories to access.
  Libcall  // A library call API.  All params must have default values.
  Rpc  // An RPC API.  All params must have default values.
  Builtin  // Globally visible, never a lib call or RPC.
  ExternC  // An external C function.
  ExternRpc  // An external RPC function.
}

// Return a name for the function type.
func getFuncTypeName(type: FuncType) -> string {
  switch type {
    FuncType.Plain => return "func"  // Includes methods.
    FuncType.Unittest => return "unittest"  // Includes methods.
    FuncType.Constructor => return "class"
    FuncType.Destructor => return "destructor"
    FuncType.Package => return "package"  // Initializes all modules in the package.
    FuncType.Module => return "module"  // Initializes the module.
    FuncType.Iterator => return "iterator"
    FuncType.Operator => return "operator"
    FuncType.Final => return "final"
    FuncType.Struct => return "struct"
    FuncType.Enum => return "enum"
    FuncType.Transformer => return "transformer"
  }
}

// Create a new function.
class Function(self, parent: Function?, type: FuncType, sym: Sym,
    linkage: Linkage, line: Line) {
  self.type = type
  self.sym = sym
  self.linkage = linkage
  self.line = line
  self.isExtern = linkage == Linkage.ExternC || linkage == Linkage.ExternRpc
  if !isnull(parent) {
    parent!.appendChildFunction(self)
    Ident(parent!, self, sym, line)
  }
  subBlock = Block(line)
  // Assume it can return until we learn otherwise.  This is only an issue when
  // evaluating recursive functions.
  subBlock.canReturn = true
  self.insertSubBlock(subBlock)

  // Return the name of the function.
  func name(self) -> string {
    return self.sym.name
  }

  func dumpParams(self, var text: string) {
    firstTime = true
    for variable in self.variables() {
      if !firstTime {
        text += ", "
      }
      firstTime = false
      if !variable.isParam {
        return
      }
      variable.dumpToString(text)
    }
  }

  // Dump the function to the end of |string| for debugging purposes.
  func dumpToString(self, var text: string) {

    func dumpFuncHeader(function :Function, var text: string) {
      text += "%s %s(" % (getFuncTypeName(function.type), function.name())
    }

    root = getRoot()
    root.indent(text)
    dumpFuncHeader(self, text)
    self.dumpParams(text)
    text += ") "
    if !isnull(self.typeExpr) {
      text += "-> "
      self.typeExpr!.dumpToString(text)
      text += " "
    }
    text += " {\n"
    getRoot().incrementIndent()
    self.subBlock!.dumpToString(text)
    for function in self.childFunctions() {
      function.dumpToString(text)
    }
    getRoot().decrementIndent()
    getRoot().indent(text)
    text += "}\n"
  }

  // Dump the function to stdout for debugging purposes.
  func dump(self) {
    text = ""
    self.dumpToString(text)
    print text
  }

  // Make a copy of the function in |destBlock|.
  func copy(self, destFunc: Function) -> Function {
    newFunction = Function(destFunc, self.type, self.sym, self.linkage, self.line)
    for variable in self.variables() {
      variable.copy(newFunction)
    }
    newBlock = self.subBlock!.copy()
    newFunction.insertSubBlock(newBlock)
    if !isnull(self.typeExpr) {
      newFunction.typeExpr = self.typeExpr!.copy()
    }
    // TODO: Comment this back in when we port templates.
    // if self.type == FuncType.Constructor {
      // self.templ.copy(newFunction)
    // }
    return newFunction
  }

  // Prepend a call statement to |childFunction| at the end of |function|.
  // |childFunction| will be called with no parameters.
  func prependFunctionCall(self, childFunction: Function) -> Statement {
    statement = self.appendFunctionCall(childFunction)
    // Move the statement to the start of the block.
    block = self.subBlock!
    block.removeStatement(statement)
    block.insertStatement(statement)
    return statement
  }

  // Append a call statement to |childFunction| at the end of |function|.
  // |childFunction| will be called with no parameters.
  func appendFunctionCall(self, childFunction: Function) -> Statement {
    ident = childFunction.firstNameIdent
    pathExpr = ident!.createPathExpr()
    text = "%s()\n" % childFunction.name()
    block = self.subBlock!
    line = Line(block.line.filepath!, text, 0u32)
    emptyParamsExpr = Expr(ExprType.List, line)
    callExpr = Expr.newBinary(ExprType.Call, pathExpr, emptyParamsExpr, line)
    statement = Statement(block, StateType.Call, line)
    statement.insertExpr(callExpr)
    return statement
  }

  // Declare an iterator.
  func newIterator(owningFunc: Function, name: Sym, selfName: Sym, linkage: Linkage,
      line: Line) -> Function {
    iteratorFunc = Function(owningFunc, FuncType.Iterator, name, linkage, line)
    Variable(iteratorFunc, true, false, selfName, null(Expr), null(Expr), false, line)
    return iteratorFunc
  }

  // Create an overloaded operator.
  func newOperator(owningFunc: Function, opType: ExprType, line: Line) -> Function {
    name = owningFunc.createUniqueSym(Sym.new(getExprTypeName(opType)))
    function = Function(owningFunc, FuncType.Operator, name, Linkage.Package, line)
    root = getRoot()
    return function
  }

  // Generate a unique name for an identifier in the function, based on |name|.
  // Just use |name| if there is no conflict, otherwise, add _n, where n is an
  // integer to make the name unique in the function.
  func createUniqueSym(self, sym: Sym) -> Sym {
    if isnull(self.findIdent(sym)) {
      return sym
    }
    counter = 1u32
    do {
      newSym = Sym.new("%s_%u" % (sym.name, counter))
      counter += 1
    } while !isnull(self.findIdent(newSym))
    return newSym
  }

  // Create a path expression to this function.
  func createPathExpr(self) -> Expr {
    identExpr = Expr.newIdent(self.sym, self.line)
    parent = self.parentFunction
    if isnull(parent) {
      return identExpr
    }
    prefixExpr = parent!.createPathExpr()
    return Expr.newBinary(ExprType.Dot, prefixExpr, identExpr, self.line)
  }
}

// Append a call statement to the module initialization function in the root function.
func insertModuleInitializationCall(moduleFunc: Function) {
  pathExpr = moduleFunc.createPathExpr()
  block = moduleFunc.subBlock!
  text = "%s()\n" % moduleFunc.name()
  line = Line(block.line.filepath!, text, 0u32)
  emptyParamsExpr = Expr(ExprType.List, line)
  callExpression = Expr.newBinary(ExprType.Call, pathExpr, emptyParamsExpr, line)
  root = getRoot()
  block = getMainFunc().subBlock!
  statement = Statement(block, StateType.Call, line)
  statement.insertExpr(callExpression)
  // Move the statement to after the last initialization call.
  lastInitializer = root.lastInitializerStatement
  block.removeStatement(statement)
  if !isnull(lastInitializer) {
    block.insertAfterStatement(lastInitializer, statement)
  } else {
    block.insertStatement(statement)
  }
  root.lastInitializerStatement = statement
}

// The root function of the function tree.
relation OneToOne Root:"Main" Function:"Main" cascade
relation DoublyLinked Function:"Parent" Function:"Child" cascade
relation OneToOne Filepath:"Module" Function:"Module"

// Create the main function.
func createMainFunc() {
  rootFilepath = Filepath("Root filepath", null(Filepath), true)
  rootLine = Line(rootFilepath, "Create main", 0u32)
  mainFunc = Function(null(Function), FuncType.Package,
        Sym.new("main"), Linkage.Package, rootLine)
  typeExpr = Expr(ExprType.IntType, rootLine)
  typeExpr.width = 32u32
  mainFunc.insertTypeExpr(typeExpr)
  getRoot().insertMainFunction(mainFunc)
  rootBlock = mainFunc.subBlock!
  rootFilepath.insertModuleFunction(mainFunc)
  nullExpr = null(Expr(ExprType.Add, rootLine))
  u32TypeExpr = Expr(ExprType.UintType, rootLine)
  stringTypeExpr = Expr(ExprType.StringType, rootLine)
  u32TypeExpr.width = 32u32
  argcVar = Variable(mainFunc, true, true, Sym.new("argc"), nullExpr, u32TypeExpr, true, rootLine)
  argvVar = Variable(mainFunc, true, true, Sym.new("argv"), nullExpr,
      stringTypeExpr, true, rootLine)
  statement = Statement(mainFunc.subBlock!, StateType.Return, rootLine)
  retVal = Expr.newConstant(Value(0i32), rootLine)
  statement.insertExpr(retVal)
}

createMainFunc()

unittest {
  use statement

  mainFunc = getMainFunc()
  rootLine = mainFunc.line
  rootFilepath = rootLine.filepath
  argcVar = mainFunc.firstVariable!
  argvVar = argcVar.nextFunctionVariable!

  func createEmptyFunction(owningFunc: Function?, name: string) -> Function {
    return Function(owningFunc, FuncType.Plain, Sym.new(name), Linkage.Module, rootLine)
  }

  func createPrintlnFunction(owningFunc: Function?, name: string, text: string) {
    function = createEmptyFunction(owningFunc, name);
    block = function.subBlock!
    Statement(block, StateType.Println, rootLine)
    return function
  }
}

unittest dumpTest {
  mainFunc.dump()
}

unittest copyTest {
  destFunc = createEmptyFunction(null(Function), "destFunc")
  destFunc = mainFunc.copy(destFunc)
  destFunc.dump()
}

unittest prependAndAppendFunctionCallTest {
  destFunc = createEmptyFunction(null(Function), "destFunc")
  mainCopy = mainFunc.copy(destFunc)
  // Create an inner function.
  topFunc = createEmptyFunction(mainCopy, "topFunc")
  botFunc = createEmptyFunction(mainCopy, "botFunc")
  lastStatement = mainCopy.appendFunctionCall(botFunc)
  firstStatement = mainCopy.prependFunctionCall(topFunc)
  subBlock = mainCopy.subBlock!
  assert subBlock.firstStatement == firstStatement
  assert subBlock.lastStatement == lastStatement
  mainCopy.dump()
}

unittest newIteratorAndOperatorTest {
  itr = Function.newIterator(mainFunc, Sym.new("testItr"), Sym.new("self"),
      Linkage.Module, rootLine)
  op = Function.newOperator(mainFunc, ExprType.Add, rootLine)
  itr.dump()
  op.dump()
  itr.destroy()
  op.destroy()
}

unittest insertModuleInitializationCallTest {
  // Create an inner function.
  function1 = createEmptyFunction(getRoot().mainFunction!, "module1")
  function2 = createEmptyFunction(getRoot().mainFunction!, "module2")
  insertModuleInitializationCall(function1)
  insertModuleInitializationCall(function2)
  getMainFunc().dump()
}

unittest createUniqueSymTest {
  baseSym = Sym.new("printTest")
  topFunc = createEmptyFunction(getMainFunc(), "topFunc")
  createPrintlnFunction(topFunc, baseSym.name, "func1")
  newSym = topFunc.createUniqueSym(baseSym)
  assert newSym.name == "printTest_1"
  createPrintlnFunction(topFunc, newSym.name, "func2")
  newSym = topFunc.createUniqueSym(baseSym)
  assert newSym.name == "printTest_2"
  createPrintlnFunction(topFunc, newSym.name, "func3")
  topFunc.dump()
}
