//  Copyright 2023 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License")
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This will likely become the Rune lexer.  For now, it is only lexing syntax files.

import io
use sym

import database.bigint as bi
import database.datatype as dt
import database.filepath as fp
import database.location as loc
import database.value as val
use char
use keytab
use token

class Lexer(self, filepath: fp.Filepath, keytab: Keytab, readFile: bool = true) {
  if filepath.text.length() == 0 {
    if readFile {
      filepath.readFile()
    }
  }
  self.pos = 0u32
  self.len = <u32>filepath.text.length()
  self.line = 1u32
  self.startPos = 0u32
  self.keytab = keytab
  filepath.insertLexer(self)

  func parseToken(self) -> Token {
    self.skipSpace()
    if self.eof() {
      return self.eofToken()
    }
    self.startPos = self.pos
    char = self.readChar()
    self.checkCharValid(char)
    c = self.filepath!.text[char.pos]
    if c == '"' {
      return self.parseString()
    } else if c == '\'' {
      return self.parseAsciiChar()
    } else if c >= '0' && c <= '9' {
      return self.parseNumber()
    } else if c == '\' {
      return self.parseEscapedIdent()
    } else if isalpha(c) || char.len > 1 {
      self.readIdentOrKeyword(char)
    }
    return self.parseNonAlphaKeyword(char)

    func isalpha(c) -> bool {
      return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z'
    }
  }

  // Skip space and comments in the input.
  func skipSpace(self) {
    do {
      if self.eof() {
        return
      }
      c = self.filepath!.text[self.pos]
    } while c == ' ' || c == '\r' || c == '\t' {
      self.pos += 1
    }
  }

  func eof(self) {
    return self.pos >= self.len
  }

  // A non-ASCII UTF-8 character will match ([\xc0-\xff][\x80-\xbf]*).
  func readChar(self) -> Char {
    char = getChar(self.filepath!.text, self.pos)
    self.pos += <u32>char.len
    return char
  }

  func eofToken(self) {
    assert self.eof()
    return Token(TokenType.Eof, loc.Location(self.filepath!, self.len, 0u32, self.line))
  }

  func error(self, msg: string) {
    location = loc.Location(self.filepath!, self.startPos, self.pos - self.startPos, self.line)
    location.error(msg)
    raise Status.InvalidArgument
  }

  func parseString(self) -> Token {
    s = ""
    do {
      self.checkNotEof("in string")
      char = self.readChar()
      c = self.filepath!.text[char.pos]
    } while c != '"' {
      if c == '\\' {
        s.append(self.readEscapedChar(false))
      } else {
        for i in range(char.pos, char.pos + <u32>char.len) {
          s.append(self.filepath!.text[i])
        }
      }
    }
    location = loc.Location(self.filepath!, self.startPos, self.pos - self.startPos, self.line)
    return Token.newValueToken(s, location)
  }

  // Read an escaped character.  If in single quotes, escape single quotes,
  // otherwise escape double quotes.
  func readEscapedChar(self, singleQuotes: bool) -> u8 {
    self.checkNotEof("in character escape sequence")
    char = self.readChar()
    c = self.filepath!.text[char.pos]
    if c == 'a' {
      return '\a'
    } else if c == 'b' {
      return '\b'
    } else if c == 'e' {
      return '\e'
    } else if c == 'f' {
      return '\f'
    } else if c == 'n' {
      return '\n'
    } else if c == 'r' {
      return '\r'
    } else if c == 't' {
      return '\t'
    } else if c == 'v' {
      return '\v'
    } else if c == '\\' {
      return '\\'
    } else if c == '"' && !singleQuotes{
      return '"'
    } else if c == '\'' && singleQuotes {
      return '\''
    } else if c == '0' {
      return '\0'
    } else if c == 'x' {
      self.checkNotEof("in hexadecimal escape sequence")
      char = self.readChar()
      hi = self.filepath!.text[char.pos]
      self.checkNotEof("in hexadecimal escape sequence")
      char = self.readChar()
      lo = self.filepath!.text[char.pos]
      if !isHexDigit(hi) || !isHexDigit(lo) {
        self.error("Non-hex digit in hexadecimal escape sequence")
      }
      return hexToChar(hi, lo)
    }
    self.startPos = char.pos
    self.error("Invalid escape sequence")
    return '\0'  // Dummy return.
  }

  func checkNotEof(self, desc: string) {
    if self.eof() {
      self.error("Unexpected end of file " + desc)
    }
  }

  func checkCharValid(self, char: Char) {
    if !char.valid {
      self.error("Invalid character")
    }
  }

  // Returns a u8 integer token.
  func parseAsciiChar(self) -> Token {
    self.checkNotEof("after single quote")
    char = self.readChar()
    self.checkCharValid(char)
    if char.len != 1 {
      self.error("Only single-byte characters can be used in single quotes")
    }
    c = self.filepath!.text[char.pos]
    if c == '\\' {
      c = self.readEscapedChar(true)
    }
    self.expectChar('\'')
    return Token.newValueToken(c, loc.Location(self.filepath!, char.pos, 1u32, self.line))
  }

  func expectChar(self, expectedChar: u8) {
    self.checkNotEof(", when expecting %s" % chr(expectedChar))
    char = self.readChar()
    c = self.filepath!.text[char.pos]
    if c != expectedChar {
      self.error("Expected %s, got %s" % (chr(expectedChar), chr(c)))
    }
  }

  func parseNumber(self) -> Token {
    self.pos -= 1  // Rewind to start.
    intVal = self.parseRawInteger()
    if self.eof() {
      location = loc.Location(self.filepath!, self.startPos, self.pos - self.startPos, self.line)
      return Token.newValueToken(intVal, location)
    }
    filepath = self.filepath!
    c = filepath.text[self.pos]
    if c == '.' || c == 'f' {
      return self.parseFloat(intVal)
    }
    if c == 'x' && self.pos == self.startPos + 1 && filepath.text[self.startPos] == '0' {
      self.pos += 1
      intVal = self.parseHexInteger()
    }
    return self.parseIntegerSuffix(intVal)
  }

  func parseIntegerSuffix(self, var intVal: bi.Bigint) -> Token {
    filepath = self.filepath!
    width = bi.Bigint(64u32)
    c = filepath.text[self.pos]
    if c == 'i' {
      intVal = intVal.cast(intVal.width + 1, true, intVal.isSecret)
    }
    if c == 'i' || c == 'u' {
      self.pos += 1
      width = self.parseWidthSpec()
    }
    intWidth = <u32>width
    if intVal.width > intWidth {
      newIntVal = intVal.resize(intWidth, true)
      if newIntVal.resize(intVal.width) != intVal {
        self.error("Constant does not fit in integer width")
      }
      intVal = newIntVal
    } else if intVal.width < intWidth {
      intVal = intVal.resize(intWidth)
    }
    location = loc.Location(filepath, self.startPos, self.pos - self.startPos, self.line)
    return Token.newValueToken(intVal, location)
  }

  func parseWidthSpec(self) {
    filepath = self.filepath!
    self.checkNotEof("in integer width spec")
    c = filepath.text[self.pos]
    if c < '1' || c > '9' {
      self.error("Invalid integer width spec")
    }
    newWidth = self.parseRawInteger()
    if newWidth > <newWidth>0xffff {
      self.error("Integer widths must be < 2^16")
    }
    return newWidth.resize(32u32)
  }

  func parseRawInteger(self) {
    filepath = self.filepath!
    width = 8u32
    intVal = bi.Bigint(0u8)
    while !self.eof() {
      c = filepath.text[self.pos]
      self.pos += 1
      if c != '_' {
        if c < '0' || c > '9' {
          self.pos -= 1  // Push the char back into the input steam.
          return intVal
        }
        if (intVal << 5u32) >> 5u32 != intVal {
          width <<= 1
          intVal = intVal.cast(width, intVal.isSigned, intVal.isSecret, false)
        }
        intVal = (intVal * <intVal>10) + <intVal>(c - '0')
      }
    }
    return intVal
  }

  func parseFloat(self, intVal) -> Token {
    return self.eofToken()  // TODO: Write me.
  }

  // Parse the hex chars, but don't parse the width spec.
  func parseHexInteger(self) -> bi.Bigint {
    filepath = self.filepath!
    intVal = bi.Bigint(0u8)
    while !self.eof() {
      c = filepath.text[self.pos]
      if c != '_' {
        if !isHexDigit(c) {
          return intVal
        }
        newIntVal = intVal << 4u32
        if newIntVal >> 4u32 != intVal {
          newIntVal = intVal.resize(intVal.width << 1u32) << 4u32
        }
        intVal = newIntVal | bi.Bigint(hexDigit(c), newIntVal.width)
      }
      self.pos += 1
    }
    return intVal
  }

  func readHex(self) {

  }

  func parseEscapedIdent(self) -> Token {
    return self.eofToken()  // TODO: Write me.
  }

  func readIdentOrKeyword(self, char: Char) -> Token {
    return self.eofToken()  // TODO: Write me.
  }

  func parseNonAlphaKeyword(self, char: Char) -> Token {
    return self.eofToken()  // TODO: Write me.
  }
}

relation OneToOne fp.Filepath Lexer cascade

unittest emptyTest {
  filepath = fp.Filepath("testdata/empty", null(fp.Filepath), false)
  keytab = Keytab()
  lexer = Lexer(filepath, keytab, false)
  assert lexer.len == 0
  assert lexer.eof()
  token = lexer.parseToken()
  assert token.type == TokenType.Eof
  lexer.destroy()
  println "Passed empty test"
}

unittest {
  func newLexer(text: string) {
    filepath = fp.Filepath("testdata/empty", null(fp.Filepath), false)
    filepath.text = text
    keytab = Keytab()
    return Lexer(filepath, keytab, false)
  }
}

unittest parseEscapedCharsTest {
  lexer = newLexer("\"\\a\\b\\e\\f\\n\\r\\t\\v\\\\\\\"\\0\\xde\\xad\"")
  token = lexer.parseToken()
  assert token.type == TokenType.String
  value = token.value!
  assert value.type == dt.Datatype.String
  s = value.stringVal
  assert s[0] == '\x07'  // Bell.
  assert s[1] == '\x08'  // Backspace.
  assert s[2] == '\x1b'  // Escape.
  assert s[3] == '\x0c'  // Formfeed.
  assert s[4] == '\x0a'  // Newline.
  assert s[5] == '\x0d'  // Return.
  assert s[6] == '\x09'  // Tab.
  assert s[7] == '\x0b'  // Vertical tab.
  assert s[8] == '\\'
  assert s[9] == '"'
  assert s[10] == '\0'
  assert s[11] == '\xde'
  assert s[12] == '\xad'
  println "Passed escaped chars test"
}

unittest badInputTest {
  // Overlong encoding of '\0'
  lexer = newLexer("\xc0\x80")
  try {
    lexer.parseToken()
    panic "Failed invalid character test"
  } except e {
    default => println "Caught invalid character"
  }
  lexer.destroy()
  lexer = newLexer("\"\\x0g\"")
  try {
    lexer.parseToken()
    panic "Failed invalid hex escape test"
  } except e {
    default => println "Caught invalid hex escape"
  }
  lexer.destroy()
  lexer = newLexer("\"\\z\"")
  try {
    lexer.parseToken()
    panic "Failed invalid escape sequence"
  } except e {
    default => println "Caught invalid escape sequence"
  }
  lexer.destroy()
  lexer = newLexer("\"no end quote")
  try {
    lexer.parseToken()
    panic "Failed to catch unexpeced end of file"
  } except e {
    default => println "Caught unexpected end of file"
  }
  println "Passed bad input test"
}

unittest parseEscapedSingleQuotedCharsTest {
  lexer = newLexer("'\\a' '\\b' '\\e' '\\f' '\\n' '\\r' '\\t' '\\v' '\\\\' '\\'' '\\0' '\\xde' '\\xad'")
  expRes = ['\x07' /* Bell */, '\x08' /* Backspace */, '\x1b' /* Escape */, '\x0c' /* Formfeed */,
      '\x0a' /* Newline */, '\x0d' /* Return */, '\x09' /* Tab */, '\x0b' /* Vertical tab */,
      '\\', '\'', '\0', '\xde', '\xad']
  i = 0
  while !lexer.eof() {
    token = lexer.parseToken()
    assert token.type == TokenType.Integer && token.value!.intVal! == bi.Bigint(expRes[i])
    i += 1
  }
  println "Passed escaped chars test"
}

unittest parseIntegerTest {
  lexer = newLexer("0 1u2 3i3 57896044618658097711785492504343953926634992332820282019728792003956564819949u256")
  expRes = ["0u64", "1u2", "3i3", "57896044618658097711785492504343953926634992332820282019728792003956564819949u256"]
  i = 0
  while !lexer.eof() {
    token = lexer.parseToken()
    println "token value = ", token.value!.intVal!.toString()
    println "expected    = ", expRes[i]
    assert token.type == TokenType.Integer && token.value!.intVal!.toString() == expRes[i]
    i += 1
  }
  println "Passed parse integer test"
}

unittest parseHexTest {
  lexer = newLexer("0x0 0xau4 0x3i3 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffedu256")
  expRes = ["0u64", "au4", "3i3", "7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffedu256"]
  i = 0
  while !lexer.eof() {
    token = lexer.parseToken()
    intValStr = token.value!.intVal!.toStringInBase(16u32)
    println "token value = ", intValStr
    println "expected    = ", expRes[i]
    assert token.type == TokenType.Integer && intValStr == expRes[i]
    i += 1
  }
  println "Passed parse integer test"
}
