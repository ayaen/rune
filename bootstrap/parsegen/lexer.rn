//  Copyright 2023 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This will likely become the Rune lexer.  For now, it is only lexing syntax files.

import io
use sym

import database.filepath as fp
import database.location as loc
use char
use keytab
use token

class Lexer(self, filepath: fp.Filepath, keytab: Keytab, readFile: bool = true) {
  filepath.appendLexer(self)
  if filepath.text.length() == 0 {
    if readFile {
      filepath.readFile()
    }
  }
  self.pos = 0u32
  self.len = <u32>self.filepath!.text.length()
  self.line = 1u32
  self.startPos = 0u32
  self.keytab = keytab

  func parseToken(self) -> Token {
    self.skipSpace()
    if self.eof() {
      return self.eofToken()
    }
    self.startPos = self.pos
    char = self.readChar()
    if !char.valid {
      self.error("Invalid character")
    }
    c = self.filepath!.text[char.pos]
    if c == '"' {
      return self.parseString()
    } else if c >= '0' && c <= '9' {
      return self.parseNumber()
    } else if c == '\' {
      return self.parseEscapedIdent()
    } else if isalpha(c) || char.len > 1 {
      self.readIdentOrKeyword(char)
    }
    return self.parseNonAlphaKeyword(char)

    func isalpha(c) -> bool {
      return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z'
    }
  }

  // Skip space and comments in the input.
  func skipSpace(self) {
    while !self.eof() && self.filepath!.text[self.pos] < ' ' {
      self.pos += 1
    }
  }

  func eof(self) {
    return self.pos >= self.len
  }

  // A non-ASCII UTF-8 character will match ([\xc0-\xff][\x80-\xbf]*).
  func readChar(self) -> Char {
    return getChar(self.filepath!.text, self.pos)
  }

  func eofToken(self) {
    assert self.eof()
    return Token(TokenType.Eof, loc.Location(self.filepath!, self.len, 0u32, self.line))
  }

  func error(self, msg: string) {
    location = loc.Location(self.filepath!, self.startPos, self.pos - self.startPos, self.line)
    location.error(msg)
    throw
  }

  func parseString(self) -> Token {
    return self.eofToken()  // TODO: Write me.
  }

  func parseNumber(self) -> Token {
    return self.eofToken()  // TODO: Write me.
  }

  func parseEscapedIdent(self) -> Token {
    return self.eofToken()  // TODO: Write me.
  }

  func readIdentOrKeyword(self, char: Char) -> Token {
    return self.eofToken()  // TODO: Write me.
  }

  func parseNonAlphaKeyword(self, char: Char) -> Token {
    return self.eofToken()  // TODO: Write me.
  }
}

relation DoublyLinked fp.Filepath Lexer cascade

unittest emptyTest {
  filepath = fp.Filepath("testdata/empty", null(fp.Filepath), false)
  keytab = Keytab()
  lexer = Lexer(filepath, keytab, false)
  assert lexer.len == 0
  assert lexer.eof()
  token = lexer.parseToken()
  assert token.type == TokenType.Eof
  println "Passed empty test"
}
